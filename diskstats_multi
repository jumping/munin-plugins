#!/usr/bin/perl
#!@@PERL@@ -w
# -*- perl -*-
# vim: sts=4 sw=4 ts=8

use strict;
use warnings;

use File::Basename;
use Carp;
use POSIX;
use Munin::Plugin;
use MIME::Base64;
use Storable qw(freeze thaw);

# Hardcoded pollinterval of 300 seconds
my $poll_interval = 300;

my $plugin_name = $Munin::Plugin::me;

# Check for multigraph capabilities
# FIXME: need_multigraph succeeds only when run from within munin.
# This should be fixed upstream, write bugreport!
need_multigraph() if ( $ENV{'MUNIN_VERSION'} );

# Handle munin 'autoconf' command
do_autoconf() if ( $ARGV[0] && $ARGV[0] eq 'autoconf' );

# FIXME: See Ticket #810
set_state_name($plugin_name) unless defined $Munin::Plugin::statefile;

# Fetch current counter values
my %cur_diskstats = fetch_device_counters();

# Handle munin 'config' command
# This can only be done after getting the device data
if ( defined $ARGV[0] && $ARGV[0] eq 'config' ) {
    do_config();
}

# Restore data from previous run
my ( $prev_time, %prev_diskstats ) = choose_old_state();

# Persist state from current run
add_new_state( time(), %cur_diskstats );

# Probably the first run for the given device, we need state to do our job,
# so let's wait for the next run.
exit if ( not defined $prev_time or not %prev_diskstats );

# Here happens the magic
generate_multigraph_data( $prev_time, \%prev_diskstats, \%cur_diskstats );

exit 0;

# FIXME:
# totals for overview graphs?
# Filter for devices for node config?
# report bugs.

########
# SUBS #
########

# generate_multigraph_data
#
# Creates the data which is needed by munin's fetch command

sub generate_multigraph_data {

    my ( $prev_time, $prev_diskstats, $cur_diskstats ) = @_;

    my %results;

    for my $device ( keys %{$cur_diskstats} ) {
        $results{$device} =
          calculate_values( $prev_time, $prev_diskstats{$device},
            $cur_diskstats{$device} );
    }

    print_values_root( \%results );

    for my $device ( keys %results ) {
        print_values_device( $device, $results{$device} );
    }
    return;
}

# choose_old_state
#
# Look through the list of old states and choose the one which is closest
# to the poll interval

sub choose_old_state {

    my (%states) = restore_state();

    return unless ( keys %states );

    my $now = time();

    my $old_delta;
    my $return_timestamp;

    for my $timestamp ( sort keys %states ) {

        # Calculate deviation from ideal interval
        my $delta = abs( $now - $timestamp - $poll_interval );

        # Safe initial delta
        $old_delta = $delta + 1 unless defined $old_delta;

        # Bail out and use previous result if it was closer to the interval
        last if ( $delta > $old_delta );

        $old_delta        = $delta;
        $return_timestamp = $timestamp;
    }
    return $return_timestamp,
      %{ thaw decode_base64 $states{$return_timestamp} };
}

# add_new_state
#
# Add the current state to the list of states
# Discard any state that is noticeable older than the poll interval

sub add_new_state {
    my ( $cur_time, %cur_diskstats ) = @_;

    my (%states) = restore_state();
    my $now = time();

    for my $timestamp ( sort keys %states ) {
        last if ( ( $now - $timestamp ) <= $poll_interval * 1.5 );
        delete $states{$timestamp};
    }

    # FIXME: There ought to be a better way to do this.
    $states{$cur_time} = encode_base64 freeze \%cur_diskstats;

    save_state(%states);
    return;
}

# calculate_values
#
# Calculates all data that get's graphed

sub calculate_values {
    my ( $prev_time, $prev_stats, $cur_stats ) = @_;

    my $bytes_per_sector = 512;

    my $interval = time() - $prev_time;

    my $read_ios  = $cur_stats->{'rd_ios'} - $prev_stats->{'rd_ios'};
    my $write_ios = $cur_stats->{'wr_ios'} - $prev_stats->{'wr_ios'};

    my $rd_ticks = $cur_stats->{'rd_ticks'} - $prev_stats->{'rd_ticks'};
    my $wr_ticks = $cur_stats->{'wr_ticks'} - $prev_stats->{'wr_ticks'};

    my $rd_sectors = $cur_stats->{'rd_sectors'} - $prev_stats->{'rd_sectors'};
    my $wr_sectors = $cur_stats->{'wr_sectors'} - $prev_stats->{'wr_sectors'};

    my $tot_ticks = $cur_stats->{'tot_ticks'} - $prev_stats->{'tot_ticks'};

    my $read_io_per_sec  = $read_ios / $interval;
    my $write_io_per_sec = $write_ios / $interval;

    my $read_bytes_per_sec  = $rd_sectors / $interval * $bytes_per_sector;
    my $write_bytes_per_sec = $wr_sectors / $interval * $bytes_per_sector;

    my $total_ios         = $read_ios + $write_ios;
    my $total_ios_per_sec = $total_ios / $interval;

    # Utilization - or "how busy is the device"?
    # If the time spent for I/O was close to 1000msec for
    # a given second, the device is nearly 100% saturated.
    my $utilization = $tot_ticks / $interval;

    # Average time an I/O takes on the block device
    my $servicetime =
      $total_ios_per_sec ? $utilization / $total_ios_per_sec : 0;

    # Average wait time for an I/O from start to finish
    # (includes queue times et al)
    my $average_wait = $total_ios ? ( $rd_ticks + $wr_ticks ) / $total_ios : 0;
    my $average_rd_wait = $read_ios  ? $rd_ticks / $read_ios  : 0;
    my $average_wr_wait = $write_ios ? $wr_ticks / $write_ios : 0;

    my $average_rq_size_in_kb =
      $total_ios
      ? ( $rd_sectors + $wr_sectors ) * $bytes_per_sector / 1024 / $total_ios
      : 0;
    my $average_rd_rq_size_in_kb =
      $read_ios ? $rd_sectors * $bytes_per_sector / 1024 / $read_ios : 0;
    my $average_wr_rq_size_in_kb =
        $write_ios
      ? $wr_sectors * $bytes_per_sector / 1024 / $write_ios
      : 0;

    my $util_print = $utilization / 10;

    return {
        utilization              => $util_print,
        servicetime              => $servicetime,
        average_wait             => $average_wait,
        average_rd_wait          => $average_rd_wait,
        average_wr_wait          => $average_wr_wait,
        read_bytes_per_sec       => $read_bytes_per_sec,
        write_bytes_per_sec      => $write_bytes_per_sec,
        read_io_per_sec          => $read_io_per_sec,
        write_io_per_sec         => $write_io_per_sec,
        average_rq_size_in_kb    => $average_rq_size_in_kb,
        average_rd_rq_size_in_kb => $average_rd_rq_size_in_kb,
        average_wr_rq_size_in_kb => $average_wr_rq_size_in_kb,
    };

}

# print_values_root
#
# Return multigraph values for root graphs

sub print_values_root {

    my ($result) = @_;

    print "multigraph ${plugin_name}_latency\n";

    for my $device ( keys %{$result} ) {

        next unless ( $cur_diskstats{$device}->{'does_latency'} );
        my $clean_device = $cur_diskstats{$device}->{'clean_device_name'};

        print "${clean_device}_avgwait.value "
          . $result->{$device}->{'average_wait'} . "\n";
    }

    print "\nmultigraph ${plugin_name}_utilization\n";

    for my $device ( keys %{$result} ) {

        next unless ( $cur_diskstats{$device}->{'does_latency'} );
        my $clean_device = $cur_diskstats{$device}->{'clean_device_name'};

        print "${clean_device}_util.value "
          . $result->{$device}->{'utilization'} . "\n";
    }

    print "\nmultigraph ${plugin_name}_throughput\n";

    for my $device ( keys %{$result} ) {
        my $clean_device = $cur_diskstats{$device}->{'clean_device_name'};
        print "${clean_device}_rdbytes.value "
          . $result->{$device}->{'read_bytes_per_sec'} . "\n";
        print "${clean_device}_wrbytes.value "
          . $result->{$device}->{'write_bytes_per_sec'} . "\n";
    }

    print "\nmultigraph ${plugin_name}_iops\n";

    for my $device ( keys %{$result} ) {
        my $clean_device = $cur_diskstats{$device}->{'clean_device_name'};
        print "${clean_device}_rdio.value "
          . $result->{$device}->{'read_io_per_sec'} . "\n";
        print "${clean_device}_wrio.value "
          . $result->{$device}->{'write_io_per_sec'} . "\n";
    }
    return;
}

# print_values_device
#
# Return multigraph values for device graphs

sub print_values_device {

    my ( $device, $result ) = @_;

    if ( $cur_diskstats{$device}->{'does_latency'} ) {
        print <<"EOF";

multigraph ${plugin_name}_latency.$device
svctm.value $result->{'servicetime'}
avgwait.value $result->{'average_wait'}
avgrdwait.value $result->{'average_rd_wait'}
avgwrwait.value $result->{'average_wr_wait'}
EOF

        print <<"EOF";

multigraph ${plugin_name}_utilization.$device
util.value $result->{'utilization'}
EOF

    }

    print <<"EOF";

multigraph ${plugin_name}_throughput.$device
rdbytes.value $result->{'read_bytes_per_sec'}
wrbytes.value $result->{'write_bytes_per_sec'}
EOF

    print <<"EOF";

multigraph ${plugin_name}_iops.$device
rdio.value $result->{'read_io_per_sec'}
wrio.value $result->{'write_io_per_sec'}
avgrqsz.value $result->{'average_rq_size_in_kb'}
avgrdrqsz.value $result->{'average_rd_rq_size_in_kb'}
avgwrrqsz.value $result->{'average_wr_rq_size_in_kb'}
EOF

    return;
}

# read_procfs
#
# Pull diskstat information from procfs

sub read_procfs {

    my $statfh;

    open $statfh, '<', '/proc/diskstats'
      or croak "Failed to open '/proc/diskstats': $!\n";

    my @lines;

    while ( my $line = <$statfh> ) {

        # Strip trailing newline and leading whitespace
        chomp $line;
        $line =~ s/^\s+//;

        my @elems = split /\s+/, $line;

        # We explicitly don't support old-style diskstats
        # There are situations where only _some_ lines (e.g.
        # partitions on older 2.6 kernels) have fewer stats
        # numbers, therefore we'll skip them silently
        if ( @elems != 14 ) {
            next;
        }
        push @lines, \@elems;
    }

    close $statfh or croak "Failed to close '/proc/diskstats': $!";
    return @lines;
}

# read_sysfs
#
# Pull diskstat information from sysfs

sub read_sysfs {

    my @devices;
    my @lines;

    @devices = glob "/sys/block/*/stat";
    @devices = map { m!/sys/block/([^/]+)/stat! } @devices;

    for my $cur_device (@devices) {
        my $stats_file = "/sys/block/$cur_device/stat";

        my $statfh;

        open $statfh, '<', $stats_file
          or croak "Failed to open '$stats_file': $!\n";

        my $line = <$statfh>;

        close $statfh or croak "Failed to close '$stats_file': $!\n";

        # Trimming whitespace
        $line =~ s/^\s+//;
        chomp $line;

        my @elems = split /\s+/, $line;

        croak "'$stats_file' doesn't contain exactly 11 values. Aborting"
          if ( @elems != 11 );

        # Translate the devicename back before storing the information
        $cur_device =~ tr#!#/#;

        # Faking missing diskstats values
        unshift @elems, ( '', '', $cur_device );

        push @lines, \@elems;
    }

    return @lines;
}

# parse_diskstats
#
# Pulls diskstat information eitehr from procfs or sysfs, parses them and provides
# helper information.

sub parse_diskstats {

    my @stats;

    if ( glob "/sys/block/*/stat" ) {

        @stats = read_sysfs();
    }
    else {
        @stats = read_procfs();
    }

    my %diskstats;

    for my $entry (@stats) {

        my %devstat;

        # Hash-Slicing for fun and profit
        @devstat{
            qw(major minor devname
              rd_ios rd_merges rd_sectors rd_ticks
              wr_ios wr_merges wr_sectors wr_ticks
              ios_in_prog tot_ticks rq_ticks)
          }
          = @{$entry};

        # Resolve devicemapper names to their LVM counterparts
        my $device = $devstat{'devname'};
        my $pretty_device;

        if ( $device =~ /^dm-\d+$/ ) {
            $pretty_device = translate_devicemapper_name($device);
        }

        $pretty_device ||= $device;

        $devstat{'pretty_device_name'} = $pretty_device;
        ( $devstat{'short_pretty_device_name'} ) = $pretty_device =~ m#/?([^/]+)$#;
        $devstat{'clean_device_name'} = clean_fieldname($device);

        # Does the device provide latency information?
        $devstat{'does_latency'} =
          $devstat{'rd_ticks'} + $devstat{'wr_ticks'} ? 1 : 0;

        $diskstats{ $devstat{'devname'} } = \%devstat;
    }

    return %diskstats;
}

# fetch_device_counters
#
# Filters partitions and devices without IOs from diskstats
# and returns them

sub fetch_device_counters {

    my %diskstats = parse_diskstats();

    my @seen_devices;
  DEVICE:
    for my $devname ( keys %diskstats ) {

        # Remove devices without traffic
        if (   $diskstats{$devname}->{'rd_ios'} == 0
            && $diskstats{$devname}->{'wr_ios'} == 0 )
        {
            delete $diskstats{$devname};
            next DEVICE;
        }

        for my $existing_device (@seen_devices) {

            # Filter out devices (partitions) which are matched by existing ones
            # e.g. sda1 -> sda, c0d0p1 -> c0d0
            if ( $devname =~ m/$existing_device/ ) {
                delete $diskstats{$devname};
                next DEVICE;
            }
        }

        push @seen_devices, $devname;
    }
    return %diskstats;
}

# translate_devicemapper_name
#
# Tries to find a devicemapper name based on a minor number
# Returns either a resolved LVM path or the original devicename

sub translate_devicemapper_name {
    my ($device) = @_;

    my ($want_minor) = $device =~ m/^dm-(\d+)$/;

    croak "Failed to extract devicemapper id" unless defined($want_minor);

    my $dm_major = find_devicemapper_major();
    croak "Failed to get device-mapper major number\n"
      unless defined $dm_major;

    for my $entry ( glob "/dev/mapper/\*" ) {

        my $rdev  = ( stat($entry) )[6];
        my $major = floor( $rdev / 256 );
        my $minor = $rdev % 256;

        if ( $major == $dm_major && $minor == $want_minor ) {

            my $pretty_name = translate_lvm_name($entry);

            $entry =~ s|/dev/||;

            return defined $pretty_name ? $pretty_name : $entry;
        }
    }

    # Return original string if the device can't be found.
    return $device;
}

# translate_lvm_name
#
# Translates devicemapper names to their nicer LVM counterparts
# e.g. /dev/mapper/VGfoo-LVbar -> /dev/VGfoo/LVbar

sub translate_lvm_name {

    my ($entry) = @_;

    my $device_name = basename($entry);

# Check for single-dash-occurence to see if this could be a lvm devicemapper device.
    if ( $device_name =~ m/(?<!-)-(?!-)/ ) {

        # split device name into vg and lv parts
        my ( $vg, $lv ) = split /(?<!-)-(?!-)/, $device_name, 2;
        return unless ( defined($vg) && defined($lv) );

        # remove extraneous dashes from vg and lv names
        $vg =~ s/--/-/g;
        $lv =~ s/--/-/g;

        $device_name = "$vg/$lv";

        # Sanity check - does the constructed device name exist?
        # Breaks unless we are root.
        if ( stat("/dev/$device_name") ) {
            return "$device_name";
        }

    }
    return;
}

# find_devicemapper_major
#
# Searches for the major number of the devicemapper device

sub find_devicemapper_major {

    my $devicefh;

    open( $devicefh, '<', '/proc/devices' )
      or croak "Failed to open '/proc/devices': $!";

    my $dm_major;

    while ( my $line = <$devicefh> ) {
        chomp $line;

        my ( $major, $name ) = split /\s+/, $line, 2;

        next unless defined $name;

        if ( $name eq 'device-mapper' ) {
            $dm_major = $major;
            last;
        }
    }
    close($devicefh);

    return $dm_major;
}

sub do_autoconf {

    my %stats;

    # Capture any croaks on the way
    if ( eval { %stats = parse_diskstats() } && keys %stats ) {

        print "yes\n";
        exit 0;
    }
    else {
        print "no\n";
        exit 1;
    }
}

sub do_config {

    do_config_root();
    do_config_device();

    exit 0;
}

# do_config_root
#
# Print the configuration for the root graphs

sub do_config_root {

    # Print config for latency

    print <<"EOF";
multigraph ${plugin_name}_latency
graph_title Disk latency overview
graph_args --base 1000
graph_vlabel milliseconds
graph_category disk

EOF

    for my $device ( sort keys %cur_diskstats ) {
        next unless $cur_diskstats{$device}->{'does_latency'};
        my $clean_device = $cur_diskstats{$device}->{'clean_device_name'};

        print <<"EOF";
${clean_device}_avgwait.label $cur_diskstats{$device}->{'pretty_device_name'} average IO Wait
${clean_device}_avgwait.type GAUGE
${clean_device}_avgwait.info Average wait time for an I/O request
${clean_device}_avgwait.min 0
EOF
    }

    
    # Print config for utilization

    print <<"EOF";

multigraph ${plugin_name}_utilization
graph_title Disk utilization overview
graph_args --base 1000 --lower-limit 0 --upper-limit 100 --rigid
graph_vlabel Percent
graph_category disk

EOF

    for my $device ( sort keys %cur_diskstats ) {
        next unless $cur_diskstats{$device}->{'does_latency'};
        my $clean_device = $cur_diskstats{$device}->{'clean_device_name'};

    print <<"EOF";
${clean_device}_util.label $cur_diskstats{$device}->{'pretty_device_name'} utilization (percent)
${clean_device}_util.type GAUGE
${clean_device}_util.info Utilization of the device
${clean_device}_util.min 0
EOF
    }


    # Print config for throughput

    print <<"EOF";

multigraph ${plugin_name}_throughput
graph_title Disk throughput overview
graph_args --base 1024
graph_vlabel Bytes/\${graph_period} read (-) / written (+)
graph_category disk
graph_width 450

EOF

    for my $device ( sort keys %cur_diskstats ) {
        my $clean_device = $cur_diskstats{$device}->{'clean_device_name'};

        print <<"EOF";
${clean_device}_rdbytes.label $cur_diskstats{$device}->{'short_pretty_device_name'}
${clean_device}_rdbytes.type GAUGE
${clean_device}_rdbytes.min 0
${clean_device}_rdbytes.graph no
${clean_device}_wrbytes.label $cur_diskstats{$device}->{'short_pretty_device_name'}
${clean_device}_wrbytes.type GAUGE
${clean_device}_wrbytes.min 0
${clean_device}_wrbytes.negative ${clean_device}_rdbytes
EOF
    }

    # Print config for iops

    print <<"EOF";

multigraph ${plugin_name}_iops
graph_title Disk IOs overview
graph_args --base 1000
graph_vlabel IOs/\${graph_period} read (-) / written (+) 
graph_category disk
graph_width 450

EOF

    for my $device ( sort keys %cur_diskstats ) {
        my $clean_device = $cur_diskstats{$device}->{'clean_device_name'};

        print <<"EOF";
${clean_device}_rdio.label $cur_diskstats{$device}->{'short_pretty_device_name'}
${clean_device}_rdio.type GAUGE
${clean_device}_rdio.min 0
${clean_device}_rdio.graph no
${clean_device}_wrio.label $cur_diskstats{$device}->{'short_pretty_device_name'}
${clean_device}_wrio.type GAUGE
${clean_device}_wrio.min 0
${clean_device}_wrio.negative ${clean_device}_rdio
EOF
    }
    print "\n";
    return;
}

# do_config_device
#
# Print the configuration for all device graphs

sub do_config_device {

    for my $device ( sort keys %cur_diskstats ) {

        # Nice name for graph
        my $pretty_device = $cur_diskstats{$device}->{'pretty_device_name'};

        if ( $cur_diskstats{$device}->{'does_latency'} ) {

            print <<"EOF";
multigraph ${plugin_name}_latency.$device
graph_title Disk latency for /dev/$pretty_device
graph_args --base 1000
graph_vlabel milliseconds
graph_category disk

svctm.label Average device IO time
svctm.type GAUGE
svctm.info Average time an I/O takes on the block device
svctm.min 0
avgwait.label Average IO Wait time
avgwait.type GAUGE
avgwait.info Average wait time for an I/O from request start to finish (includes queue times et al)
avgwait.min 0
avgrdwait.label Average Read IO Wait time
avgrdwait.type GAUGE
avgrdwait.info Average wait time for a read I/O from request start to finish (includes queue times et al)
avgrdwait.min 0
avgwrwait.label Average Write IO Wait time
avgwrwait.type GAUGE
avgwrwait.info Average wait time for a write I/O from request start to finish (includes queue times et al)
avgwrwait.min 0

EOF

            print <<"EOF";
multigraph ${plugin_name}_utilization.$device
graph_title Disk utilization for /dev/$pretty_device
graph_args --base 1000 --lower-limit 0 --upper-limit 100 --rigid
graph_vlabel Percent
graph_category disk

util.label Device utilization
util.type GAUGE
util.info Utilization of the device. If the time spent for I/O is close to 1000msec for a given second, the device is nearly 100% saturated.
util.min 0

EOF

        }

        print <<"EOF";
multigraph ${plugin_name}_throughput.$device
graph_title Disk throughput for /dev/$pretty_device
graph_args --base 1024
graph_vlabel Bytes/second
graph_category disk

rdbytes.label Read Bytes
rdbytes.type GAUGE
rdbytes.min 0
wrbytes.label Write Bytes
wrbytes.type GAUGE
wrbytes.min 0

EOF

        print <<"EOF";
multigraph ${plugin_name}_iops.$device
graph_title Disk IOs for /dev/$pretty_device
graph_args --base 1000
graph_vlabel Units/second
graph_category disk

rdio.label Read IO/sec
rdio.type GAUGE
rdio.min 0
wrio.label Write IO/sec
wrio.type GAUGE
wrio.min 0
avgrqsz.label Average Request Size (KiB)
avgrqsz.type GAUGE
avgrqsz.min 0
avgrdrqsz.label Average Read Request Size (KiB)
avgrdrqsz.type GAUGE
avgrdrqsz.min 0
avgwrrqsz.label Average Write Request Size (KiB)
avgwrrqsz.type GAUGE
avgwrrqsz.min 0

EOF

    }
    return;
}

__END__

=head1 NAME

diskstats_multi - Munin multigraph plugin to monitor various values provided
via C</proc/diskstats> or C</sys/block/*/stat>

=head1 APPLICABLE SYSTEMS

Linux 2.6 systems with extended block device statistics enabled.


=head1 CONFIGURATION

None needed.

This plugin displays nicer device-mapper device names if it is run as
root, but it functions as needed without root privilege.  To configure
for running as root enter this in a plugin configuration file:

  [diskstats_multi]
    user root

=head1 INTERPRETATION

Among the more self-describing or well-known values like C<throughput>
(Bytes per second) there are a few which might need further introduction.


=head2 Device Utilization

Linux provides a counter which increments in a millisecond-interval for as long
as there are outstanding I/O requests. If this counter is close to 1000msec
in a given 1 second timeframe the device is nearly 100% saturated. This plugin
provides values averaged over a 5 minute time frame per default, so it can't
catch short-lived saturations, but it'll give a nice trend for semi-uniform
load patterns as they're expected in most server or multi-user environments.


=head2 Device IO Time

The C<Device IO Time> takes the counter described under C<Device Utilization>
and divides it by the number of I/Os that happened in the given time frame,
resulting in an average time per I/O on the block-device level.

This value can give you a good comparison base amongst different controllers,
storage subsystems and disks for similiar workloads.


=head2 Syscall Wait Time

These values describe the average time it takes between an application issuing
a syscall resulting in a hit to a blockdevice to the syscall returning to the
application.

The values are bound to be higher (at least for read requests) than the time
it takes the device itself to fulfill the requests, since calling overhead,
queuing times and probably a dozen other things are included in those times.

These are the values to watch out for when an user complains that C<the disks
are too slow!>.


=head3 What causes a block device hit?

A non-exhaustive list:

=over

=item * Reads from files when the given range is not in the page cache or the O_DIRECT
flag is set.

=item * Writes to files if O_DIRECT or O_SYNC is set or sys.vm.dirty_(background_)ratio
is exceeded.

=item * Filesystem metadata operations (stat(2), getdents(2), file creation,
modification of any of the values returned by stat(2), etc.)

=item * The pdflush daemon writing out dirtied pages

=item * (f)sync

=item * Swapping

=item * raw device I/O (mkfs, dd, etc.)

=back

=head1 ACKNOWLEDGEMENTS

The core logic of this script is based on the B<iostat> tool of the
B<sysstat> package written and maintained by Sebastien Godard.

=head1 SEE ALSO

See C<Documentation/iostats.txt> in your Linux source tree for further
information about the C<numbers> involved in this module.

L<http://www.westnet.com/~gsmith/content/linux-pdflush.htm> has a nice
writeup about the pdflush daemon.

=head1 VERSION

  $Id$

=head1 MAGIC MARKERS

  #%# family=auto
  #%# capabilities=autoconf

=head1 AUTHOR

Michael Renner <michael.renner@amd.co.at>

=head1 LICENSE

GPLv2


=cut
