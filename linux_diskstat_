#!/usr/bin/perl -w

# (c) 2008, Michael Renner <michael.renner@amd.co.at>

# TODO:
# Autoconfig
# split read/write latency stats
# Convert gauges to derive/counter where feasible
# munindoc

# Acknowledgements:
# The logic of this module is based on the iostat tool of the sysstat package
# written and maintained by Sebastien Godard


# See Documentation/iostats.txt in your linux source tree for further
# information about the statistics fields.

use strict;


use Munin::Plugin;
use Carp;
use Data::Dumper;
use File::Basename;

my $basename = basename($0);
my ($mode, $device) = $basename =~ m/linux_diskstat_(\w+)_(\w+)/;



if ( defined $ARGV[0] && $ARGV[0] eq 'autoconf') {
	if (-f '/proc/diskstats') {

		if (read_diskstats()) {
			print "yes\n";
			exit 0;
		}
	}
	print "no\n";
	exit 1;
}

if ( defined $ARGV[0] && $ARGV[0] eq 'suggest') {

	my %diskstats = parse_diskstats();

	my %suggested_devices;

DEVICE:
	for my $devname (sort keys %diskstats) {

		# Skip devices without traffic
		next if ($diskstats{$devname}->{'rd_ios'} == 0 && $diskstats{$devname}->{'wr_ios'} == 0);

		# Skip device-mapper devices
		next if ($devname =~ /^dm-\d+/);

		for my $existing_device (keys %suggested_devices) {

			# Filter out devices (partitions) which are matched by existing ones
			# e.g. sda1 -> sda, c0d0p1 -> c0d0
			next DEVICE if ($devname =~ m/$existing_device/);

		}
		$suggested_devices{$devname} = 1;
	}

	for my $mode (qw(latency iops throughput)) {
		for my $device (sort keys %suggested_devices) {

			print "${mode}_$device\n";
		}
	}

	exit 0;
}


if (not defined $device) {
	croak "Didn't get a device name. Aborting\n";
}


if ( defined $ARGV[0] && $ARGV[0] eq 'config') {

	if ($mode eq 'latency') {

		print <<EOF;
graph_title Disk latency for /dev/$device
graph_args --base 1000
graph_vlabel ms
graph_category disk

util.label Device utilization (in percent)
util.type GAUGE
util.info Utilization of the device. If the time spent for I/O was close to 1000msec for a given second, the device is nearly 100% saturated.
svctm.label Average IO time (ms)
svctm.type GAUGE
svctm.info Average time an I/O takes on the block device
avgwait.label Average IO Wait time (ms)
avgwait.type GAUGE
avgwait.info Average wait time for an I/O from request start to finish (includes queue times et al)

EOF

	}
	elsif ($mode eq 'throughput') {

		print <<EOF;
graph_title Disk throughput for /dev/$device
graph_args --base 1024
graph_vlabel Bytes/\${graph_period}
graph_category disk

rdbytes.label Read Bytes
rdbytes.type GAUGE
wrbytes.label Write Bytes
wrbytes.type GAUGE

EOF
	}
	elsif ($mode eq 'iops') {

		print <<EOF;
graph_title Disk IOs for /dev/$device
graph_args --base 1000
graph_vlabel Units/\${graph_period}
graph_category disk

rdio.label Read IO/sec
rdio.type GAUGE
wrio.label Write IO/sec
wrio.type GAUGE
avgrqsz.label Average Request Size (KiB)
avgrqsz.type GAUGE

EOF

	}
	else {
		croak "Unknown mode $mode\n";
	}

	exit 0;
}



my %cur_diskstat = fetch_device_counters($device);


my ($prev_time, %prev_diskstat) = restore_state();

save_state(time(), %cur_diskstat);

# Probably the first run for the given device, we need state to do our job,
# so let's wait for the next run.
if (not defined $prev_time or not %prev_diskstat) {
	exit;
}

calculate_and_print_values($prev_time, \%prev_diskstat, \%cur_diskstat);



sub calculate_and_print_values {
	my ($prev_time, $prev_stats, $cur_stats) = @_;

	my $bytes_per_sector = 512;

	my $interval = time() - $prev_time;

	my $read_ios = $cur_stats->{'rd_ios'} - $prev_stats->{'rd_ios'};
	my $write_ios = $cur_stats->{'wr_ios'} - $prev_stats->{'wr_ios'};
	my $total_ios = $read_ios + $write_ios;

	my $rd_ticks = $cur_stats->{'rd_ticks'} - $prev_stats->{'rd_ticks'};
	my $wr_ticks = $cur_stats->{'wr_ticks'} - $prev_stats->{'wr_ticks'};

	my $rd_sectors = $cur_stats->{'rd_sectors'} - $prev_stats->{'rd_sectors'};
	my $wr_sectors = $cur_stats->{'wr_sectors'} - $prev_stats->{'wr_sectors'};

	my $tot_ticks = $cur_stats->{'tot_ticks'} - $prev_stats->{'tot_ticks'};

	my $read_io_per_sec = $read_ios / $interval;
	my $write_io_per_sec = $write_ios / $interval;

	my $read_bytes_per_sec = $rd_sectors / $interval * $bytes_per_sector;
	my $write_bytes_per_sec = $wr_sectors / $interval * $bytes_per_sector;


	my $ios_per_sec = $total_ios / $interval;

	# Utilization - or "how busy is the device"?
	# If the time spent for I/O was close to 1000msec for a given second, the device is nearly 100% saturated.
	my $utilization = $tot_ticks / $interval;

	# Average time an I/O takes on the block device
	my $servicetime = $ios_per_sec ? $utilization / $ios_per_sec : 0;

	# Average wait time for an I/O from start to finish (includes queue times et al)
	my $average_wait = $total_ios ? ($rd_ticks + $wr_ticks) / $total_ios : 0;

	my $average_rq_size_in_kb = $total_ios ? ($rd_sectors + $wr_sectors) * $bytes_per_sector / 1024 / $total_ios : 0;

	my $util_print = $utilization / 10;


	if ($mode eq 'latency') {
		print <<EOF;

util.value $util_print
svctm.value $servicetime
avgwait.value $average_wait

EOF
	}
	elsif ($mode eq 'throughput') {

		print <<EOF;

rdbytes.value $read_bytes_per_sec
wrbytes.value $write_bytes_per_sec

EOF
	}
	elsif ($mode eq 'iops') {

		print <<EOF;

rdio.value $read_io_per_sec
wrio.value $write_io_per_sec
avgrqsz.value $average_rq_size_in_kb

EOF

	}
	else {
		croak "Unknown mode $mode\n";
	}

}

sub read_diskstats {

	open STAT, '< /proc/diskstats' or croak "Failed to open '/proc/diskstats': $!";

	my @lines;

	for my $line (<STAT>) {
		# Strip trailing newline and leading whitespace
		chomp $line;
		$line =~ s/^\s+//;

		my @elems = split /\s+/, $line;

		# We explicitly don't support old-style diskstats
		if (@elems != 14) {
			return undef;
		}
		push @lines, \@elems;
	}

	close STAT or croak "Failed to close '/proc/diskstats': $!";
	return @lines;
}

sub parse_diskstats {

	my @stats = read_diskstats();
	
	my %diskstats;

	for my $entry (@stats) {

		my %devstat;

		# Hash-Slicing for fun and profit
		@devstat{qw(major minor devname
				rd_ios rd_merges rd_sectors rd_ticks
				wr_ios wr_merges wr_sectors wr_ticks
				ios_in_prog tot_ticks rq_ticks)} = @{$entry};

		$diskstats{$devstat{'devname'}} = \%devstat;
	}

	return %diskstats;
}

sub fetch_device_counters {

	my ($want_device) = @_;

	my %diskstats = parse_diskstats();

	for my $devname (keys %diskstats) {

		if ($want_device eq $devname) {
			return %{$diskstats{$devname}};
		}
	}
	return undef;
}
