#!/usr/bin/perl -w

# Munin markers:
#%# family=auto
#%# capabilities=autoconf suggest

# (c) 2008, Michael Renner <michael.renner@amd.co.at>

# TODO:
# drop combined stats where split out read/write exists if it's nicer that way.
# report graph_scale no should imply graph_args --rigid
# rigid is rigid in both ways. curse you!
# fix read_diskstats undef/exception handling
# fix error reporting when unsupported diskstats values are detected

=head1 NAME

linux_diskstats_ - Munin plugin to monitor various values provided
via C</proc/diskstats>

=head1 APPLICABLE SYSTEMS

Linux 2.6 systems with extended block device statistics enabled.


=head1 INTERPRETATION

Among the more self-describing or well-known values like C<throughput>
(Bytes per second) there are a few which might need further introduction.


=head2 Device Utilization

Linux provides a counter which increments in a millisecond-interval for as long
as there are outstanding I/O requests. If this counter is close to 1000msec
in a given 1 second timeframe the device is nearly 100% saturated. This plugin
provides values averaged over a 5 minute time frame per default, so it can't
catch short-lived saturations, but it'll give a nice trend for semi-uniform
load patterns as they're expected in most server or multi-user environments.


=head2 Device IO Time

The C<Device IO Time> takes the counter described under C<Device Utilization>
and divides it by the number of I/Os that happened in the given time frame,
resulting in an average time per I/O on the block-device level.

This value can give you a good comparison base amongst different controllers,
storage subsystems and disks for similiar workloads.


=head2 Syscall Wait Time

These values describe the average time it takes between an application issuing
a syscall resulting in a hit to a blockdevice to the syscall returning to the
application.

The values are bound to be higher (at least for read requests) than the time
it takes the device itself to fulfill the requests, since calling overhead,
queuing times and probably a dozen other things are included in those times.

These are the values to watch out for when an user complains that C<the disks
are too slow!>.


=head3 What causes a block device hit?

A non-exhaustive list:

=over

=item * Reads from files when the given range is not in the page cache or the O_DIRECT
flag is set.

=item * Writes to files if O_DIRECT or O_SYNC is set or sys.vm.dirty_(background_)ratio
is exceeded.

=item * Filesystem metadata operations (stat(2), getdents(2), file creation,
modification of any of the values returned by stat(2), etc.)

=item * The pdflush daemon writing out dirtied pages

=item * (f)sync

=item * Swapping

=item * raw device I/O (mkfs, dd, etc.)

=back

=head1 ACKNOWLEDGEMENTS

The core logic of this script is based on the B<iostat> tool of the B<sysstat>
package written and maintained by Sebastien Godard.

=head1 SEE ALSO

See C<Documentation/iostats.txt> in your Linux source tree for further information
about the C<numbers> involved in this module.

L<http://www.westnet.com/~gsmith/content/linux-pdflush.htm> has a nice writeup
about the pdflush daemon.

=head1 AUTHOR

Michael Renner <michael.renner@amd.co.at>

=head1 LICENSE

GPLv2


=cut


use strict;


use File::Basename;
use Carp;

# We load our own version of save/restore_state if Munin::Plugin is unavailable.
# Don't try this at home
eval { require Munin::Plugin; Munin::Plugin->import; };

if ($@) {
	fake_munin_plugin();
}



############
# autoconf #
############

if ( defined $ARGV[0] && $ARGV[0] eq 'autoconf') {
	if (-f '/proc/diskstats') {

		if (read_diskstats()) {
			print "yes\n";
			exit 0;
		}
	}
	print "no\n";
	exit 1;
}


###########
# suggest #
###########

if ( defined $ARGV[0] && $ARGV[0] eq 'suggest') {

	my %diskstats = parse_diskstats();

	my %suggested_devices;

DEVICE:
	for my $devname (sort keys %diskstats) {

		# Skip devices without traffic
		next if ($diskstats{$devname}->{'rd_ios'} == 0 && $diskstats{$devname}->{'wr_ios'} == 0);

		# Skip device-mapper devices
		next if ($devname =~ /^dm-\d+$/);

		for my $existing_device (keys %suggested_devices) {

			# Filter out devices (partitions) which are matched by existing ones
			# e.g. sda1 -> sda, c0d0p1 -> c0d0
			next DEVICE if ($devname =~ m/$existing_device/);

		}
		$suggested_devices{$devname} = 1;
	}

	for my $mode (qw(latency iops throughput)) {
		for my $device (sort keys %suggested_devices) {

			$device = translate_device_name($device);
			print "${mode}_$device\n";
		}
	}

	exit 0;
}


my $basename = basename($0);
my ($mode, $device) = $basename =~ m/linux_diskstat_(\w+)_([\w-]+)$/;
$device = translate_device_name($device);

if (not defined $device) {
	croak "Didn't get a device name. Aborting\n";
}


##########
# config #
##########

if ( defined $ARGV[0] && $ARGV[0] eq 'config') {

	if ($mode eq 'latency') {

		print <<EOF;
graph_title Disk latency for /dev/$device
graph_args --base 1000
graph_category disk

util.label Device utilization (percent)
util.type GAUGE
util.info Utilization of the device. If the time spent for I/O is close to 1000msec for a given second, the device is nearly 100% saturated.
svctm.label Average device IO time (ms)
svctm.type GAUGE
svctm.info Average time an I/O takes on the block device
avgwait.label Average IO Wait time (ms)
avgwait.type GAUGE
avgwait.info Average wait time for an I/O from request start to finish (includes queue times et al)
avgrdwait.label Average Read IO Wait time (ms)
avgrdwait.type GAUGE
avgrdwait.info Average wait time for a read I/O from request start to finish (includes queue times et al)
avgwrwait.label Average Write IO Wait time (ms)
avgwrwait.type GAUGE
avgwrwait.info Average wait time for a write I/O from request start to finish (includes queue times et al)

EOF

	}
	elsif ($mode eq 'throughput') {

		print <<EOF;
graph_title Disk throughput for /dev/$device
graph_args --base 1024
graph_vlabel Bytes/\${graph_period}
graph_category disk

rdbytes.label Read Bytes
rdbytes.type GAUGE
wrbytes.label Write Bytes
wrbytes.type GAUGE

EOF
	}
	elsif ($mode eq 'iops') {

		print <<EOF;
graph_title Disk IOs for /dev/$device
graph_args --base 1000
graph_vlabel Units/\${graph_period}
graph_category disk

rdio.label Read IO/sec
rdio.type GAUGE
wrio.label Write IO/sec
wrio.type GAUGE
avgrqsz.label Average Request Size (KiB)
avgrqsz.type GAUGE
avgrdrqsz.label Average Read Request Size (KiB)
avgrdrqsz.type GAUGE
avgwrrqsz.label Average Write Request Size (KiB)
avgwrrqsz.type GAUGE

EOF

	}
	else {
		croak "Unknown mode $mode\n";
	}
	exit 0;
}


########
# MAIN #
########


my %cur_diskstat = fetch_device_counters($device);


my ($prev_time, %prev_diskstat) = restore_state();

save_state(time(), %cur_diskstat);

# Probably the first run for the given device, we need state to do our job,
# so let's wait for the next run.
exit if (not defined $prev_time or not %prev_diskstat);

calculate_and_print_values($prev_time, \%prev_diskstat, \%cur_diskstat);



########
# SUBS #
########

sub calculate_and_print_values {
	my ($prev_time, $prev_stats, $cur_stats) = @_;

	my $bytes_per_sector = 512;

	my $interval = time() - $prev_time;

	my $read_ios = $cur_stats->{'rd_ios'} - $prev_stats->{'rd_ios'};
	my $write_ios = $cur_stats->{'wr_ios'} - $prev_stats->{'wr_ios'};

	my $rd_ticks = $cur_stats->{'rd_ticks'} - $prev_stats->{'rd_ticks'};
	my $wr_ticks = $cur_stats->{'wr_ticks'} - $prev_stats->{'wr_ticks'};

	my $rd_sectors = $cur_stats->{'rd_sectors'} - $prev_stats->{'rd_sectors'};
	my $wr_sectors = $cur_stats->{'wr_sectors'} - $prev_stats->{'wr_sectors'};

	my $tot_ticks = $cur_stats->{'tot_ticks'} - $prev_stats->{'tot_ticks'};


	my $read_io_per_sec = $read_ios / $interval;
	my $write_io_per_sec = $write_ios / $interval;

	my $read_bytes_per_sec = $rd_sectors / $interval * $bytes_per_sector;
	my $write_bytes_per_sec = $wr_sectors / $interval * $bytes_per_sector;


	my $total_ios = $read_ios + $write_ios;
	my $total_ios_per_sec = $total_ios / $interval;

	# Utilization - or "how busy is the device"?
	# If the time spent for I/O was close to 1000msec for a given second, the device is nearly 100% saturated.
	my $utilization = $tot_ticks / $interval;

	# Average time an I/O takes on the block device
	my $servicetime = $total_ios_per_sec ? $utilization / $total_ios_per_sec : 0;

	# Average wait time for an I/O from start to finish (includes queue times et al)
	my $average_wait = $total_ios ? ($rd_ticks + $wr_ticks) / $total_ios : 0;
	my $average_rd_wait = $read_ios ? $rd_ticks / $read_ios : 0;
	my $average_wr_wait = $write_ios ? $wr_ticks / $write_ios : 0;

	my $average_rq_size_in_kb = $total_ios ? ($rd_sectors + $wr_sectors) * $bytes_per_sector / 1024 / $total_ios : 0;
	my $average_rd_rq_size_in_kb = $read_ios ? $rd_sectors * $bytes_per_sector / 1024 / $read_ios : 0;
	my $average_wr_rq_size_in_kb = $write_ios ? $wr_sectors * $bytes_per_sector / 1024 / $write_ios : 0;

	my $util_print = $utilization / 10;


	if ($mode eq 'latency') {
		print <<EOF;

util.value $util_print
svctm.value $servicetime
avgwait.value $average_wait
avgrdwait.value $average_rd_wait
avgwrwait.value $average_wr_wait

EOF
	}
	elsif ($mode eq 'throughput') {

		print <<EOF;

rdbytes.value $read_bytes_per_sec
wrbytes.value $write_bytes_per_sec

EOF
	}
	elsif ($mode eq 'iops') {

		print <<EOF;

rdio.value $read_io_per_sec
wrio.value $write_io_per_sec
avgrqsz.value $average_rq_size_in_kb
avgrdrqsz.value $average_rd_rq_size_in_kb
avgwrrqsz.value $average_wr_rq_size_in_kb

EOF

	}
	else {
		croak "Unknown mode $mode\n";
	}

}

sub read_diskstats {

	open STAT, '< /proc/diskstats' or croak "Failed to open '/proc/diskstats': $!\n";

	my @lines;

	for my $line (<STAT>) {
		# Strip trailing newline and leading whitespace
		chomp $line;
		$line =~ s/^\s+//;

		my @elems = split /\s+/, $line;

		# We explicitly don't support old-style diskstats
		if (@elems != 14) {
			next;
		}
		push @lines, \@elems;
	}

	close STAT or croak "Failed to close '/proc/diskstats': $!";
	return @lines;
}

sub read_sysfs {

	my ($want_device) = @_;

	my $stats_file = "/sys/block/$want_device/stat";

	open STAT, "< $stats_file" or croak "Failed to open '$stats_file': $!\n";

	my $line = <STAT>;
	$line =~ s/^\s+//;
	my @elems = split /\s+/, $line;

	croak "'$stats_file' doesn't contain exactly 11 values. Aborting" if (@elems != 11);

	# Faking missing diskstats values
	unshift @elems, ('', '', $want_device);

	close STAT or croak "Failed to close '$stats_file': $!\n";

	return \@elems;
}


sub parse_diskstats {

	my ($want_device) = @_;

	my @stats;

	if ($want_device && -e "/sys/block/$want_device/stat") {

		@stats = read_sysfs($want_device);
	}
	else {
		@stats = read_diskstats();
	}
	
	my %diskstats;

	for my $entry (@stats) {

		my %devstat;

		# Hash-Slicing for fun and profit
		@devstat{qw(major minor devname
				rd_ios rd_merges rd_sectors rd_ticks
				wr_ios wr_merges wr_sectors wr_ticks
				ios_in_prog tot_ticks rq_ticks)} = @{$entry};

		$diskstats{$devstat{'devname'}} = \%devstat;
	}

	return %diskstats;
}

sub fetch_device_counters {

	my ($want_device) = @_;

	my %diskstats = parse_diskstats($want_device);

	for my $devname (keys %diskstats) {

		if ($want_device eq $devname) {
			return %{$diskstats{$devname}};
		}
	}
	return undef;
}

sub translate_device_name {

	my ($device) = @_;

	$device =~ tr#-/#/-#;
	return $device;
}


sub fake_munin_plugin {
        my $eval_code = <<'EOF';

use Storable;
my $storable_filename = basename($0);
$storable_filename = "/tmp/munin-state-$storable_filename";

sub save_state {
        my @state = @_;

        if ( not -e $storable_filename or -f $storable_filename ) {
                store \@state, $storable_filename or croak "Failed to persist state to '$storable_filename': $!\n";
        }
        else {
                croak "$storable_filename is probably not a regular file. Please delete it.\n";
        }
}

sub restore_state {

        if (-f $storable_filename) {
                my $state = retrieve($storable_filename);
                return @{$state};
        }
        else {
                return undef;
        }
}
EOF

        eval($eval_code);

}

