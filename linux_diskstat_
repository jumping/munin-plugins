#!/usr/bin/perl -w

# (c) 2008, Michael Renner <michael.renner@amd.co.at>

use strict;


use Munin::Plugin;
use Carp;
use Data::Dumper;
use File::Basename;

my $basename = basename($0);
my ($device) = $basename =~ m/linux_diskstat_(\w+)/;


if ( defined $ARGV[0] && $ARGV[0] eq 'config') {

	print <<EOF;
graph_title Linux diskstats
graph_args --base 1024
graph_vlabel quux/\${graph_period}
graph_category disk

rdio.label Read IO/sec
rdio.type GAUGE
wrio.label Write IO/sec
wrio.type GAUGE
rdkb.label Read KiB/sec
rdkb.type GAUGE
wrkb.label Read KiB/sec
wrkb.type GAUGE
util.label Device utilization (in percent)
util.type GAUGE
svctm.label Average IO time
svctm.type GAUGE
avgwait.label Average IO Wait time
avgwait.type GAUGE
avgrqsz.label Average Request Size
avgrqsz.type GAUGE

EOF

	exit 0;
}


if (not defined $device) {
	croak "Didn't get a device name. Aborting\n";
}

my %cur_diskstat = fetch_device_counters($device);


my ($prev_time, %prev_diskstat) = restore_state();

# Probably the first run for the given device, we need state for
# doing our job, so let's wait for the next run.
if (not defined $prev_time or not %prev_diskstat) {
	save_state(time(), %cur_diskstat);
	exit;
}

calculate_values($prev_time, \%prev_diskstat, \%cur_diskstat);

save_state(time(), %cur_diskstat);


sub calculate_values {
	my ($prev_time, $prev_stats, $cur_stats) = @_;

	my $sectors_per_kb = 2;

	my $interval = time() - $prev_time;

	my $read_ios = $cur_stats->{'rd_ios'} - $prev_stats->{'rd_ios'};
	my $write_ios = $cur_stats->{'wr_ios'} - $prev_stats->{'wr_ios'};
	my $total_ios = $read_ios + $write_ios;

	my $rd_ticks = $cur_stats->{'rd_ticks'} - $prev_stats->{'rd_ticks'};
	my $wr_ticks = $cur_stats->{'wr_ticks'} - $prev_stats->{'wr_ticks'};

	my $rd_sectors = $cur_stats->{'rd_sectors'} - $prev_stats->{'rd_sectors'};
	my $wr_sectors = $cur_stats->{'wr_sectors'} - $prev_stats->{'wr_sectors'};

	my $tot_ticks = $cur_stats->{'tot_ticks'} - $prev_stats->{'tot_ticks'};

	my $read_io_per_sec = $read_ios / $interval;
	my $write_io_per_sec = $write_ios / $interval;

	my $read_kb_per_sec = $rd_sectors / $interval / $sectors_per_kb;
	my $write_kb_per_sec = $wr_sectors / $interval / $sectors_per_kb;


	my $ios_per_sec = $total_ios / $interval;

	# Utilization - or "how busy is the device"?
	# If the time spent for I/O was close to 1000msec for a given time range, the device is nearly 100% saturated.
	my $utilization = $tot_ticks / $interval;

	# Servicetime == average time an I/O takes.
	my $servicetime = $ios_per_sec ? $utilization / $ios_per_sec : 0;

	# Average wait time for an I/O 
	my $average_wait = $total_ios ? ($rd_ticks + $wr_ticks) / $total_ios : 0;

	my $average_rq_size = $total_ios ? ($rd_sectors + $wr_sectors) / $total_ios : 0;

#	print "Interval: $interval. rdio: $read_io_per_sec, rdkb: $read_kb_per_sec, wrio: $write_io_per_sec, wrkb: $write_kb_per_sec\n";
#	print "util: $utilization, svct: $servicetime, await: $average_wait, avrqsz: $average_rq_size\n";

	my $util_print = $utilization / 10;
	print <<EOF;
rdio.value $read_io_per_sec
wrio.value $write_io_per_sec
rdkb.value $read_kb_per_sec
wrkb.value $write_kb_per_sec
util.value $util_print
svctm.value $servicetime
avgwait.value $average_wait
avgrqsz.value $average_rq_size

EOF

}

sub fetch_device_counters {

	my ($device) = @_;

	open STAT, '< /proc/diskstats' or croak "Failed to open '/proc/diskstats': $!";

	for my $line (<STAT>) {
		# Strip trailing newline and leading whitespace
		chomp $line;
		$line =~ s/^\s+//;

		my @elems = split /\s+/, $line;

		# We explicitly don't support old-style diskstats
		if (@elems != 14) {
			croak "Line $line doesn't have 14 fields as expected, aborting";
		}

		my %devstat;

		# Hash-Slicing for fun and profit
		@devstat{qw(major minor devname
				rd_ios rd_merges rd_sectors rd_ticks
				wr_ios wr_merges wr_sectors wr_ticks
				ios_in_prog tot_ticks rq_ticks)} = @elems;

		if ($device eq $devstat{'devname'}) {
			return %devstat;
		}
	}
	return undef;
}
