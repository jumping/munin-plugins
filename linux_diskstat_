#!/usr/bin/perl -w

# (c) 2008, Michael Renner <michael.renner@amd.co.at>

use strict;


use Munin::Plugin;
use Carp;
use Data::Dumper;


my %cur_diskstat = fetch_device_counters('sdb');


my ($prev_time, %prev_diskstat) = restore_state();

calculate_values($prev_time, \%prev_diskstat, \%cur_diskstat);

save_state(time(), %cur_diskstat);


sub calculate_values {
	my ($prev_time, $prev_stats, $cur_stats) = @_;

	my $sectors_per_kb = 2;

	my $interval = time() - $prev_time;

	my $read_ios = $cur_stats->{'rd_ios'} - $prev_stats->{'rd_ios'};
	my $write_ios = $cur_stats->{'wr_ios'} - $prev_stats->{'wr_ios'};
	my $total_ios = $read_ios + $write_ios;

	my $rd_ticks = $cur_stats->{'rd_ticks'} - $prev_stats->{'rd_ticks'};
	my $wr_ticks = $cur_stats->{'wr_ticks'} - $prev_stats->{'wr_ticks'};

	my $rd_sectors = $cur_stats->{'rd_sectors'} - $prev_stats->{'rd_sectors'};
	my $wr_sectors = $cur_stats->{'wr_sectors'} - $prev_stats->{'wr_sectors'};

	my $tot_ticks = $cur_stats->{'tot_ticks'} - $prev_stats->{'tot_ticks'};

	my $read_io_per_sec = $read_ios / $interval;
	my $write_io_per_sec = $write_ios / $interval;

	my $read_kb_per_sec = $rd_sectors / $interval / $sectors_per_kb;
	my $write_kb_per_sec = $wr_sectors / $interval / $sectors_per_kb;


	my $ios_per_sec = $total_ios / $interval;

	# Utilization - or "how busy is the device"?
	# If the time spent for I/O was close to 1000msec for a given time range, the device is nearly 100% saturated.
	my $utilization = $tot_ticks / $interval;

	# Servicetime == average time an I/O takes.
	my $servicetime = $ios_per_sec ? $utilization / $ios_per_sec : 0;

	# Average wait time for an I/O 
	my $average_wait = $total_ios ? ($rd_ticks + $wr_ticks) / $total_ios : 0;

	my $average_rq_size = $total_ios ? ($rd_sectors + $wr_sectors) / $total_ios : 0;

	print "Interval: $interval. rdio: $read_io_per_sec, rdkb: $read_kb_per_sec, wrio: $write_io_per_sec, wrkb: $write_kb_per_sec\n";
	print "util: $utilization, svct: $servicetime, await: $average_wait, avrqsz: $average_rq_size\n";

}

sub fetch_device_counters {

	my ($device) = @_;

	open STAT, '< /proc/diskstats' or croak "Failed to open '/proc/diskstats': $!";

	for my $line (<STAT>) {
		# Strip trailing newline and leading whitespace
		chomp $line;
		$line =~ s/^\s+//;

		my @elems = split /\s+/, $line;

		# We explicitly don't support old-style diskstats
		if (@elems != 14) {
			croak "Line $line doesn't have 14 fields as expected, aborting";
		}

		my %devstat;

		# Hash-Slicing for fun and profit
		@devstat{qw(major minor devname
				rd_ios rd_merges rd_sectors rd_ticks
				wr_ios wr_merges wr_sectors wr_ticks
				ios_in_prog tot_ticks rq_ticks)} = @elems;

		if ($device eq $devstat{'devname'}) {
			return %devstat;
		}
	}
	return undef;
}
